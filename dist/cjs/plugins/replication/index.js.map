{"version":3,"file":"index.js","names":["_rxjs","require","_index","_index2","_index3","_rxError","_replicationHelper","_rxDatabaseInternalStore","_plugin","_rxStorageHelper","_overwritable","_hooks","REPLICATION_STATE_BY_COLLECTION","exports","WeakMap","RxReplicationState","replicationIdentifier","collection","deletedField","pull","push","live","retryTime","autoStart","toggleOnDocumentVisible","subs","subjects","received","Subject","sent","error","canceled","BehaviorSubject","active","received$","asObservable","sent$","error$","canceled$","active$","wasStarted","startQueue","PROMISE_RESOLVE_VOID","onCancel","callOnStart","undefined","remoteEvents$","metaInfoPromise","metaInstanceCollectionName","database","hashFunction","name","join","metaInstanceSchema","getRxReplicationMetaInstanceSchema","schema","jsonSchema","hasEncryption","collectionName","replicationStates","getFromMapOrCreate","onClose","cancel","Object","keys","forEach","key","defineProperty","get","startPromise","Promise","res","document","addEventListener","visibilityState","handler","isStopped","isVisible","start","isLeader","pause","removeEventListener","_proto","prototype","then","_start","internalReplicationState","events","paused","next","reSync","preventHibernateBrowserTab","pullModifier","modifier","DEFAULT_MODIFIER","pushModifier","metaInfo","metaInstance","all","storage","createStorageInstance","databaseName","databaseInstanceToken","token","multiInstance","options","password","devMode","overwritable","isDevMode","addConnectedStorageToCollection","replicateRxStorageInstance","pushBatchSize","batchSize","pullBatchSize","initialCheckpoint","upstream","downstream","forkInstance","storageInstance","identifier","conflictHandler","replicationHandler","masterChangeStream$","pipe","filter","_v","mergeMap","ev","useEv","flatClone","documents","handlePulledDocuments","map","d","masterChangesSince","checkpoint","done","result","isStoppedOrPaused","err","emitError","newRxError","errors","toArray","er","errorToPlainJson","direction","awaitRetry","ensureNotFalsy","useResult","masterWrite","rows","runAsyncPluginHooks","useRowsOrNull","row","newDocumentState","assumedMasterState","swapDefaultDeletedTodeletedField","useRows","arrayFilterNotEmpty","length","Array","isArray","pushRows","args","rxdb","conflicts","subscribe","processed","down","up","writeToMasterRow","combineLatest","isActive","stream$","awaitRxStorageReplicationFirstInSync","awaitRxStorageReplicationInSync","_cancel","isPaused","getValue","awaitInitialReplication","awaitInSync","t","requestIdlePromise","emitEvent","catch","doNotClose","PROMISE_RESOLVE_FALSE","promises","fn","toPromise","cancelRxStorageReplication","checkpointQueue","close","sub","unsubscribe","complete","remove","removeConnectedStorageFromCollection","replicateRxCollection","waitForLeadership","addRxPlugin","RxDBLeaderElectionPlugin","replicationState","startReplicationOnLeaderShip","mustWaitForLeadership","waitTillRun","PROMISE_RESOLVE_TRUE"],"sources":["../../../../src/plugins/replication/index.ts"],"sourcesContent":["/**\n * This plugin contains the primitives to create\n * a RxDB client-server replication.\n * It is used in the other replication plugins\n * but also can be used as standalone with a custom replication handler.\n */\n\nimport {\n    BehaviorSubject,\n    combineLatest,\n    filter,\n    mergeMap,\n    Observable,\n    Subject,\n    Subscription\n} from 'rxjs';\nimport type {\n    ReplicationOptions,\n    ReplicationPullHandlerResult,\n    ReplicationPullOptions,\n    ReplicationPushOptions,\n    RxCollection,\n    RxDocumentData,\n    RxError,\n    RxJsonSchema,\n    RxReplicationPullStreamItem,\n    RxReplicationWriteToMasterRow,\n    RxStorageInstance,\n    RxStorageInstanceReplicationState,\n    RxStorageReplicationMeta,\n    RxTypeError,\n    WithDeleted\n} from '../../types/index.d.ts';\nimport { RxDBLeaderElectionPlugin } from '../leader-election/index.ts';\nimport {\n    arrayFilterNotEmpty,\n    ensureNotFalsy,\n    errorToPlainJson,\n    flatClone,\n    getFromMapOrCreate,\n    PROMISE_RESOLVE_FALSE,\n    PROMISE_RESOLVE_TRUE,\n    PROMISE_RESOLVE_VOID,\n    toArray,\n    toPromise\n} from '../../plugins/utils/index.ts';\nimport {\n    awaitRxStorageReplicationFirstInSync,\n    awaitRxStorageReplicationInSync,\n    cancelRxStorageReplication,\n    getRxReplicationMetaInstanceSchema,\n    replicateRxStorageInstance\n} from '../../replication-protocol/index.ts';\nimport { newRxError } from '../../rx-error.ts';\nimport {\n    awaitRetry,\n    DEFAULT_MODIFIER,\n    swapDefaultDeletedTodeletedField,\n    handlePulledDocuments,\n    preventHibernateBrowserTab\n} from './replication-helper.ts';\nimport {\n    addConnectedStorageToCollection,\n    removeConnectedStorageFromCollection\n} from '../../rx-database-internal-store.ts';\nimport { addRxPlugin } from '../../plugin.ts';\nimport { hasEncryption } from '../../rx-storage-helper.ts';\nimport { overwritable } from '../../overwritable.ts';\nimport {\n    runAsyncPluginHooks\n} from '../../hooks.ts';\n\n\nexport const REPLICATION_STATE_BY_COLLECTION: WeakMap<RxCollection, RxReplicationState<any, any>[]> = new WeakMap();\n\nexport class RxReplicationState<RxDocType, CheckpointType> {\n    public readonly subs: Subscription[] = [];\n    public readonly subjects = {\n        received: new Subject<RxDocumentData<RxDocType>>(), // all documents that are received from the endpoint\n        sent: new Subject<WithDeleted<RxDocType>>(), // all documents that are send to the endpoint\n        error: new Subject<RxError | RxTypeError>(), // all errors that are received from the endpoint, emits new Error() objects\n        canceled: new BehaviorSubject<boolean>(false), // true when the replication was canceled\n        active: new BehaviorSubject<boolean>(false) // true when something is running, false when not\n    };\n\n    readonly received$: Observable<RxDocumentData<RxDocType>> = this.subjects.received.asObservable();\n    readonly sent$: Observable<WithDeleted<RxDocType>> = this.subjects.sent.asObservable();\n    readonly error$: Observable<RxError | RxTypeError> = this.subjects.error.asObservable();\n    readonly canceled$: Observable<any> = this.subjects.canceled.asObservable();\n    readonly active$: Observable<boolean> = this.subjects.active.asObservable();\n\n    wasStarted: boolean = false;\n\n    readonly metaInfoPromise: Promise<{ collectionName: string, schema: RxJsonSchema<RxDocumentData<RxStorageReplicationMeta<RxDocType, any>>> }>;\n\n    public startPromise: Promise<void>;\n\n    /**\n     * start/pause/cancel/remove must never run\n     * in parallel to avoid a wide range of bugs.\n     */\n    public startQueue: Promise<any> = PROMISE_RESOLVE_VOID;\n\n    public onCancel: (() => void)[] = [];\n\n    constructor(\n        /**\n         * The identifier, used to flag revisions\n         * and to identify which documents state came from the remote.\n         */\n        public readonly replicationIdentifier: string,\n        public readonly collection: RxCollection<RxDocType, unknown, unknown, unknown>,\n        public readonly deletedField: string,\n        public readonly pull?: ReplicationPullOptions<RxDocType, CheckpointType>,\n        public readonly push?: ReplicationPushOptions<RxDocType>,\n        public readonly live?: boolean,\n        public retryTime?: number,\n        public autoStart?: boolean,\n        public toggleOnDocumentVisible?: boolean\n    ) {\n        this.metaInfoPromise = (async () => {\n            const metaInstanceCollectionName = 'rx-replication-meta-' + await collection.database.hashFunction([\n                this.collection.name,\n                this.replicationIdentifier\n            ].join('-'));\n            const metaInstanceSchema = getRxReplicationMetaInstanceSchema(\n                this.collection.schema.jsonSchema,\n                hasEncryption(this.collection.schema.jsonSchema)\n            );\n            return {\n                collectionName: metaInstanceCollectionName,\n                schema: metaInstanceSchema\n            };\n        })();\n        const replicationStates = getFromMapOrCreate(\n            REPLICATION_STATE_BY_COLLECTION,\n            collection,\n            () => []\n        );\n        replicationStates.push(this);\n\n        // stop the replication when the collection gets closed\n        this.collection.onClose.push(() => this.cancel());\n\n        // create getters for the observables\n        Object.keys(this.subjects).forEach(key => {\n            Object.defineProperty(this, key + '$', {\n                get: function () {\n                    return this.subjects[key].asObservable();\n                }\n            });\n        });\n        const startPromise = new Promise<void>(res => {\n            this.callOnStart = res;\n        });\n        this.startPromise = startPromise;\n\n        if (\n            this.toggleOnDocumentVisible &&\n            typeof document !== 'undefined' &&\n            typeof document.addEventListener === 'function' &&\n            typeof document.visibilityState === 'string'\n        ) {\n            const handler = () => {\n                if (this.isStopped()) {\n                    return;\n                }\n                const isVisible = document.visibilityState === 'visible';\n                if (isVisible) {\n                    this.start();\n                } else {\n                    /**\n                     * Only pause if not the current leader.\n                     * If no tab is visible, the elected leader should still continue\n                     * the replication.\n                     */\n                    if (!this.collection.database.isLeader()) {\n                        this.pause();\n                    }\n                }\n            }\n            document.addEventListener('visibilitychange', handler);\n            this.onCancel.push(\n                () => document.removeEventListener('visibilitychange', handler)\n            );\n        }\n    }\n\n    private callOnStart: () => void = undefined as any;\n\n    public internalReplicationState?: RxStorageInstanceReplicationState<RxDocType>;\n    public metaInstance?: RxStorageInstance<RxStorageReplicationMeta<RxDocType, CheckpointType>, any, {}, any>;\n    public remoteEvents$: Subject<RxReplicationPullStreamItem<RxDocType, CheckpointType>> = new Subject();\n\n\n    public start(): Promise<void> {\n        this.startQueue = this.startQueue.then(() => {\n            return this._start();\n        });\n        return this.startQueue;\n    }\n\n    public async _start(): Promise<void> {\n        if (this.isStopped()) {\n            return;\n        }\n\n        if (this.internalReplicationState) {\n            this.internalReplicationState.events.paused.next(false);\n        }\n\n        /**\n         * If started after a pause,\n         * just re-sync once and continue.\n         */\n        if (this.wasStarted) {\n            this.reSync();\n            return;\n        }\n        this.wasStarted = true;\n\n\n        if (!this.toggleOnDocumentVisible) {\n            preventHibernateBrowserTab(this);\n        }\n\n        // fill in defaults for pull & push\n        const pullModifier = this.pull && this.pull.modifier ? this.pull.modifier : DEFAULT_MODIFIER;\n        const pushModifier = this.push && this.push.modifier ? this.push.modifier : DEFAULT_MODIFIER;\n\n        const database = this.collection.database;\n        const metaInfo = await this.metaInfoPromise;\n\n        const [metaInstance] = await Promise.all([\n            this.collection.database.storage.createStorageInstance<RxStorageReplicationMeta<RxDocType, CheckpointType>>({\n                databaseName: database.name,\n                collectionName: metaInfo.collectionName,\n                databaseInstanceToken: database.token,\n                multiInstance: database.multiInstance,\n                options: {},\n                schema: metaInfo.schema,\n                password: database.password,\n                devMode: overwritable.isDevMode()\n            }),\n            addConnectedStorageToCollection(\n                this.collection,\n                metaInfo.collectionName,\n                metaInfo.schema\n            )\n        ]);\n        this.metaInstance = metaInstance;\n\n        this.internalReplicationState = replicateRxStorageInstance({\n            pushBatchSize: this.push && this.push.batchSize ? this.push.batchSize : 100,\n            pullBatchSize: this.pull && this.pull.batchSize ? this.pull.batchSize : 100,\n            initialCheckpoint: {\n                upstream: this.push ? this.push.initialCheckpoint : undefined,\n                downstream: this.pull ? this.pull.initialCheckpoint : undefined\n            },\n            forkInstance: this.collection.storageInstance,\n            metaInstance: this.metaInstance,\n            hashFunction: database.hashFunction,\n            identifier: 'rxdbreplication' + this.replicationIdentifier,\n            conflictHandler: this.collection.conflictHandler,\n            replicationHandler: {\n                masterChangeStream$: this.remoteEvents$.asObservable().pipe(\n                    filter(_v => !!this.pull),\n                    mergeMap(async (ev) => {\n                        if (ev === 'RESYNC') {\n                            return ev;\n                        }\n                        const useEv = flatClone(ev);\n                        useEv.documents = handlePulledDocuments(this.collection, this.deletedField, useEv.documents);\n                        useEv.documents = await Promise.all(\n                            useEv.documents.map(d => pullModifier(d))\n                        );\n                        return useEv;\n                    })\n                ),\n                masterChangesSince: async (\n                    checkpoint: CheckpointType | undefined,\n                    batchSize: number\n                ) => {\n                    if (!this.pull) {\n                        return {\n                            checkpoint: null,\n                            documents: []\n                        };\n                    }\n                    /**\n                     * Retries must be done here in the replication primitives plugin,\n                     * because the replication protocol itself has no\n                     * error handling.\n                     */\n                    let done = false;\n                    let result: ReplicationPullHandlerResult<RxDocType, CheckpointType> = {} as any;\n                    while (!done && !this.isStoppedOrPaused()) {\n                        try {\n                            result = await this.pull.handler(\n                                checkpoint,\n                                batchSize\n                            );\n                            done = true;\n                        } catch (err: any | Error | Error[]) {\n                            const emitError = newRxError('RC_PULL', {\n                                checkpoint,\n                                errors: toArray(err).map(er => errorToPlainJson(er)),\n                                direction: 'pull'\n                            });\n                            this.subjects.error.next(emitError);\n                            await awaitRetry(this.collection, ensureNotFalsy(this.retryTime));\n                        }\n                    }\n\n                    if (this.isStoppedOrPaused()) {\n                        return {\n                            checkpoint: null,\n                            documents: []\n                        };\n                    }\n\n                    const useResult = flatClone(result);\n                    useResult.documents = handlePulledDocuments(this.collection, this.deletedField, useResult.documents);\n                    useResult.documents = await Promise.all(\n                        useResult.documents.map(d => pullModifier(d))\n                    );\n                    return useResult;\n                },\n                masterWrite: async (\n                    rows: RxReplicationWriteToMasterRow<RxDocType>[]\n                ) => {\n                    if (!this.push) {\n                        return [];\n                    }\n                    let done = false;\n\n                    await runAsyncPluginHooks('preReplicationMasterWrite', {\n                        rows,\n                        collection: this.collection\n                    });\n\n                    const useRowsOrNull = await Promise.all(\n                        rows.map(async (row) => {\n                            row.newDocumentState = await pushModifier(row.newDocumentState);\n                            if (row.newDocumentState === null) {\n                                return null;\n                            }\n                            if (row.assumedMasterState) {\n                                row.assumedMasterState = await pushModifier(row.assumedMasterState);\n                            }\n                            if (this.deletedField !== '_deleted') {\n                                row.newDocumentState = swapDefaultDeletedTodeletedField(this.deletedField, row.newDocumentState) as any;\n                                if (row.assumedMasterState) {\n                                    row.assumedMasterState = swapDefaultDeletedTodeletedField(this.deletedField, row.assumedMasterState) as any;\n                                }\n                            }\n                            return row;\n                        })\n                    );\n                    const useRows: RxReplicationWriteToMasterRow<RxDocType>[] = useRowsOrNull.filter(arrayFilterNotEmpty);\n\n                    let result: WithDeleted<RxDocType>[] = null as any;\n\n                    // In case all the rows have been filtered and nothing has to be sent\n                    if (useRows.length === 0) {\n                        done = true;\n                        result = [];\n                    }\n\n                    while (!done && !this.isStoppedOrPaused()) {\n                        try {\n                            result = await this.push.handler(useRows);\n                            /**\n                             * It is a common problem that people have wrongly behaving backend\n                             * that do not return an array with the conflicts on push requests.\n                             * So we run this check here to make it easier to debug.\n                             * @link https://github.com/pubkey/rxdb/issues/4103\n                             */\n                            if (!Array.isArray(result)) {\n                                throw newRxError(\n                                    'RC_PUSH_NO_AR',\n                                    {\n                                        pushRows: rows,\n                                        direction: 'push',\n                                        args: { result }\n                                    }\n                                );\n                            }\n                            done = true;\n                        } catch (err: any | Error | Error[] | RxError) {\n                            const emitError = (err as RxError).rxdb ? err : newRxError('RC_PUSH', {\n                                pushRows: rows,\n                                errors: toArray(err).map(er => errorToPlainJson(er)),\n                                direction: 'push'\n                            });\n                            this.subjects.error.next(emitError);\n                            await awaitRetry(this.collection, ensureNotFalsy(this.retryTime));\n                        }\n                    }\n                    if (this.isStoppedOrPaused()) {\n                        return [];\n                    }\n\n                    await runAsyncPluginHooks('preReplicationMasterWriteDocumentsHandle', {\n                        result,\n                        collection: this.collection\n                    });\n\n                    const conflicts = handlePulledDocuments(this.collection, this.deletedField, ensureNotFalsy(result));\n                    return conflicts;\n                }\n            }\n        });\n\n        this.subs.push(\n            this.internalReplicationState.events.error.subscribe(err => {\n                this.subjects.error.next(err);\n            }),\n            this.internalReplicationState.events.processed.down\n                .subscribe(row => this.subjects.received.next(row.document as any)),\n            this.internalReplicationState.events.processed.up\n                .subscribe(writeToMasterRow => {\n                    this.subjects.sent.next(writeToMasterRow.newDocumentState);\n                }),\n            combineLatest([\n                this.internalReplicationState.events.active.down,\n                this.internalReplicationState.events.active.up\n            ]).subscribe(([down, up]) => {\n                const isActive = down || up;\n                this.subjects.active.next(isActive);\n            })\n        );\n\n        if (\n            this.pull &&\n            this.pull.stream$ &&\n            this.live\n        ) {\n            this.subs.push(\n                this.pull.stream$.subscribe({\n                    next: ev => {\n                        if (!this.isStoppedOrPaused()) {\n                            this.remoteEvents$.next(ev);\n                        }\n                    },\n                    error: err => {\n                        this.subjects.error.next(err);\n                    }\n                })\n            );\n        }\n\n        /**\n         * Non-live replications run once\n         * and then automatically get canceled.\n         */\n        if (!this.live) {\n            await awaitRxStorageReplicationFirstInSync(this.internalReplicationState);\n            await awaitRxStorageReplicationInSync(this.internalReplicationState);\n            await this._cancel();\n        }\n        this.callOnStart();\n    }\n\n    pause() {\n        this.startQueue = this.startQueue.then(() => {\n            /**\n             * It must be possible to .pause() the replication\n             * at any time, even if it has not been started yet.\n             */\n            if (this.internalReplicationState) {\n                this.internalReplicationState.events.paused.next(true);\n            }\n        });\n        return this.startQueue;\n    }\n\n    isPaused(): boolean {\n        return !!(this.internalReplicationState && this.internalReplicationState.events.paused.getValue());\n    }\n\n    isStopped(): boolean {\n        return !!this.subjects.canceled.getValue();\n    }\n\n    isStoppedOrPaused() {\n        return this.isPaused() || this.isStopped();\n    }\n\n    async awaitInitialReplication(): Promise<void> {\n        await this.startPromise;\n        return awaitRxStorageReplicationFirstInSync(\n            ensureNotFalsy(this.internalReplicationState)\n        );\n    }\n\n    /**\n     * Returns a promise that resolves when:\n     * - All local data is replicated with the remote\n     * - No replication cycle is running or in retry-state\n     *\n     * WARNING: USing this function directly in a multi-tab browser application\n     * is dangerous because only the leading instance will ever be replicated,\n     * so this promise will not resolve in the other tabs.\n     * For multi-tab support you should set and observe a flag in a local document.\n     */\n    async awaitInSync(): Promise<true> {\n        await this.startPromise;\n        await awaitRxStorageReplicationFirstInSync(ensureNotFalsy(this.internalReplicationState));\n\n        /**\n         * To reduce the amount of re-renders and make testing\n         * and to make the whole behavior more predictable,\n         * we await these things multiple times.\n         * For example the state might be in sync already and at the\n         * exact same time a pull.stream$ event comes in and we want to catch\n         * that in the same call to awaitInSync() instead of resolving\n         * while actually the state is not in sync.\n         */\n        let t = 2;\n        while (t > 0) {\n            t--;\n\n            /**\n             * Often awaitInSync() is called directly after a document write,\n             * like in the unit tests.\n             * So we first have to await the idleness to ensure that all RxChangeEvents\n             * are processed already.\n             */\n            await this.collection.database.requestIdlePromise();\n            await awaitRxStorageReplicationInSync(ensureNotFalsy(this.internalReplicationState));\n        }\n\n        return true;\n    }\n\n    reSync() {\n        this.remoteEvents$.next('RESYNC');\n    }\n    emitEvent(ev: RxReplicationPullStreamItem<RxDocType, CheckpointType>) {\n        this.remoteEvents$.next(ev);\n    }\n\n\n    async cancel() {\n        this.startQueue = this.startQueue.catch(() => { }).then(async () => {\n            await this._cancel();\n        });\n        await this.startQueue;\n    }\n\n    async _cancel(doNotClose = false): Promise<any> {\n        if (this.isStopped()) {\n            return PROMISE_RESOLVE_FALSE;\n        }\n\n        const promises: Promise<any>[] = this.onCancel.map(fn => toPromise(fn()));\n\n        if (this.internalReplicationState) {\n            await cancelRxStorageReplication(this.internalReplicationState);\n        }\n        if (this.metaInstance && !doNotClose) {\n            promises.push(\n                ensureNotFalsy(this.internalReplicationState).checkpointQueue\n                    .then(() => ensureNotFalsy(this.metaInstance).close())\n            );\n        }\n\n        this.subs.forEach(sub => sub.unsubscribe());\n        this.subjects.canceled.next(true);\n\n        this.subjects.active.complete();\n        this.subjects.canceled.complete();\n        this.subjects.error.complete();\n        this.subjects.received.complete();\n        this.subjects.sent.complete();\n\n        return Promise.all(promises);\n    }\n\n    async remove() {\n        this.startQueue = this.startQueue.then(async () => {\n            const metaInfo = await this.metaInfoPromise;\n            await this._cancel(true);\n            await ensureNotFalsy(this.internalReplicationState).checkpointQueue\n                .then(() => ensureNotFalsy(this.metaInstance).remove());\n            await removeConnectedStorageFromCollection(\n                this.collection,\n                metaInfo.collectionName,\n                metaInfo.schema\n            );\n        });\n        return this.startQueue;\n    }\n}\n\n\nexport function replicateRxCollection<RxDocType, CheckpointType>(\n    {\n        replicationIdentifier,\n        collection,\n        deletedField = '_deleted',\n        pull,\n        push,\n        live = true,\n        retryTime = 1000 * 5,\n        waitForLeadership = true,\n        autoStart = true,\n        toggleOnDocumentVisible = false\n    }: ReplicationOptions<RxDocType, CheckpointType>\n): RxReplicationState<RxDocType, CheckpointType> {\n    addRxPlugin(RxDBLeaderElectionPlugin);\n\n    /**\n     * It is a common error to forget to add these config\n     * objects. So we check here because it makes no sense\n     * to start a replication with neither push nor pull.\n     */\n    if (!pull && !push) {\n        throw newRxError('UT3', {\n            collection: collection.name,\n            args: {\n                replicationIdentifier\n            }\n        });\n    }\n\n    const replicationState = new RxReplicationState<RxDocType, CheckpointType>(\n        replicationIdentifier,\n        collection,\n        deletedField,\n        pull,\n        push,\n        live,\n        retryTime,\n        autoStart,\n        toggleOnDocumentVisible\n    );\n\n    startReplicationOnLeaderShip(waitForLeadership, replicationState);\n    return replicationState as any;\n}\n\n\nexport function startReplicationOnLeaderShip(\n    waitForLeadership: boolean,\n    replicationState: RxReplicationState<any, any>\n) {\n    /**\n     * Always await this Promise to ensure that the current instance\n     * is leader when waitForLeadership=true\n     */\n    const mustWaitForLeadership = waitForLeadership && replicationState.collection.database.multiInstance;\n    const waitTillRun: Promise<any> = mustWaitForLeadership ? replicationState.collection.database.waitForLeadership() : PROMISE_RESOLVE_TRUE;\n    return waitTillRun.then(() => {\n        if (replicationState.isStopped()) {\n            return;\n        }\n        if (replicationState.autoStart) {\n            replicationState.start();\n        }\n    });\n}\n"],"mappings":"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","ignoreList":[]}