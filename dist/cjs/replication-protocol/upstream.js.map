{"version":3,"file":"upstream.js","names":["_rxjs","require","_rxStorageHelper","_index","_checkpoint","_conflicts","_helper","_metaInstance","_index2","_rxError","startReplicationUpstream","state","input","initialCheckpoint","upstream","checkpointDoc","getLastCheckpointDoc","setCheckpoint","replicationHandler","streamQueue","up","then","upstreamInitialSync","processTasks","timer","initialSyncStartTime","openTasks","persistenceQueue","PROMISE_RESOLVE_FALSE","nonPersistedFromMaster","docs","sub","forkInstance","changeStream","subscribe","eventBulk","events","paused","getValue","stats","forkChangeStreamEmit","push","task","time","active","next","waitBeforePersist","subResync","masterChangeStream$","pipe","filter","ev","firstValueFrom","canceled","unsubscribe","checkpointQueue","lastCheckpoint","promises","Set","_loop","size","Promise","race","Array","from","upResult","getChangedDocumentsSince","pushBatchSize","documents","length","stackCheckpoints","checkpoint","promise","persistToMaster","ensureNotFalsy","add","catch","delete","resolvedPromises","all","hadConflicts","find","r","firstSyncDone","taskWithTime","shift","console","log","context","downstreamBulkWriteFlag","appendToArray","map","documentData","forEach","docData","docId","primaryPath","upDocsById","useCheckpoint","docIds","Object","keys","rememberCheckpointBeforeReturn","assumedMasterState","getAssumedMasterState","writeRowsToMaster","writeRowsToMasterIds","writeRowsToMeta","forkStateById","fullDocData","writeDocToDocState","hasAttachments","keepMeta","assumedMasterDoc","metaDocument","isResolvedConflict","_rev","conflictHandler","isEqual","getHeightOfRevision","_meta","identifier","undefined","newDocumentState","getMetaWriteRow","writeRowsArray","values","conflictIds","conflictsById","writeBatches","batchArray","writeBatch","row","fillWriteDataForAttachmentsChange","clone","masterWriteResult","masterWrite","conflictDoc","id","useWriteRowsToMeta","has","processed","metaInstance","bulkWrite","stripAttachmentsDataFromMetaWriteRows","hadConflictWrites","persistToMasterHadConflicts","conflictWriteFork","conflictWriteMeta","entries","realMasterState","writeToMasterRow","resolveConflictError","resolved","resolvedConflicts","output","previous","document","persistToMasterConflictWrites","forkWriteResult","mustThrow","error","status","throwMe","newRxError","writeError","useMetaWrites","success","getWrittenDocumentsFromBulkWriteResponse","unhandledError"],"sources":["../../../src/replication-protocol/upstream.ts"],"sourcesContent":["import { firstValueFrom, filter } from 'rxjs';\nimport {\n    getChangedDocumentsSince,\n    getWrittenDocumentsFromBulkWriteResponse,\n    stackCheckpoints\n} from '../rx-storage-helper.ts';\nimport type {\n    BulkWriteRow,\n    BulkWriteRowById,\n    ById,\n    EventBulk,\n    RxDocumentData,\n    RxError,\n    RxReplicationWriteToMasterRow,\n    RxStorageChangeEvent,\n    RxStorageInstanceReplicationState,\n    RxStorageReplicationMeta,\n    WithDeleted\n} from '../types/index.d.ts';\nimport {\n    appendToArray,\n    batchArray,\n    clone,\n    ensureNotFalsy,\n    getHeightOfRevision,\n    PROMISE_RESOLVE_FALSE\n} from '../plugins/utils/index.ts';\nimport {\n    getLastCheckpointDoc,\n    setCheckpoint\n} from './checkpoint.ts';\nimport {\n    resolveConflictError\n} from './conflicts.ts';\nimport {\n    stripAttachmentsDataFromMetaWriteRows,\n    writeDocToDocState\n} from './helper.ts';\nimport {\n    getAssumedMasterState,\n    getMetaWriteRow\n} from './meta-instance.ts';\nimport { fillWriteDataForAttachmentsChange } from '../plugins/attachments/index.ts';\nimport { newRxError } from '../rx-error.ts';\n\n/**\n * Writes all document changes from the fork to the master.\n * The upstream runs on two modes:\n * - For initial replication, a checkpoint-iteration is used\n * - For ongoing local writes, we just subscribe to the changeStream of the fork.\n *   In contrast to the master, the fork can be assumed to never loose connection,\n *   so we do not have to prepare for missed out events.\n */\nexport async function startReplicationUpstream<RxDocType, CheckpointType>(\n    state: RxStorageInstanceReplicationState<RxDocType>\n) {\n    if (\n        state.input.initialCheckpoint &&\n        state.input.initialCheckpoint.upstream\n    ) {\n        const checkpointDoc = await getLastCheckpointDoc(state, 'up');\n        if (!checkpointDoc) {\n            await setCheckpoint(\n                state,\n                'up',\n                state.input.initialCheckpoint.upstream\n            );\n        }\n    }\n\n    const replicationHandler = state.input.replicationHandler;\n    state.streamQueue.up = state.streamQueue.up.then(() => {\n        return upstreamInitialSync().then(() => {\n            return processTasks();\n        });\n    });\n\n    // used to detect which tasks etc can in it at which order.\n    let timer = 0;\n    let initialSyncStartTime = -1;\n\n    type Task = EventBulk<RxStorageChangeEvent<RxDocType>, any> | 'RESYNC';\n    type TaskWithTime = {\n        task: Task;\n        time: number;\n    };\n    const openTasks: TaskWithTime[] = [];\n    let persistenceQueue: Promise<boolean> = PROMISE_RESOLVE_FALSE;\n    const nonPersistedFromMaster: {\n        checkpoint?: CheckpointType;\n        docs: ById<RxDocumentData<RxDocType>>;\n    } = {\n        docs: {}\n    };\n\n    const sub = state.input.forkInstance.changeStream()\n        .subscribe((eventBulk) => {\n            if (state.events.paused.getValue()) {\n                return;\n            }\n\n\n            state.stats.up.forkChangeStreamEmit = state.stats.up.forkChangeStreamEmit + 1;\n            openTasks.push({\n                task: eventBulk,\n                time: timer++\n            });\n            if (!state.events.active.up.getValue()) {\n                state.events.active.up.next(true);\n            }\n            if (state.input.waitBeforePersist) {\n                return state.input.waitBeforePersist()\n                    .then(() => processTasks());\n            } else {\n                return processTasks();\n            }\n        });\n    const subResync = replicationHandler\n        .masterChangeStream$\n        .pipe(\n            filter(ev => ev === 'RESYNC')\n        )\n        .subscribe(() => {\n            openTasks.push({\n                task: 'RESYNC',\n                time: timer++\n            });\n            processTasks();\n        });\n\n    // unsubscribe when replication is canceled\n    firstValueFrom(\n        state.events.canceled.pipe(\n            filter(canceled => !!canceled)\n        )\n    ).then(() => {\n        sub.unsubscribe();\n        subResync.unsubscribe();\n    });\n\n\n    async function upstreamInitialSync() {\n        state.stats.up.upstreamInitialSync = state.stats.up.upstreamInitialSync + 1;\n        if (state.events.canceled.getValue()) {\n            return;\n        }\n\n        state.checkpointQueue = state.checkpointQueue.then(() => getLastCheckpointDoc(state, 'up'));\n        let lastCheckpoint: CheckpointType = await state.checkpointQueue;\n\n        const promises: Set<Promise<any>> = new Set();\n\n        while (!state.events.canceled.getValue()) {\n            initialSyncStartTime = timer++;\n\n            /**\n             * Throttle the calls to\n             * forkInstance.getChangedDocumentsSince() so that\n             * if the pushing to the remote is slower compared to the\n             * pulling out of forkInstance, we do not block the UI too much\n             * and have a big memory spike with all forkInstance documents.\n             */\n            if (promises.size > 3) {\n                await Promise.race(Array.from(promises));\n            }\n            const upResult = await getChangedDocumentsSince(\n                state.input.forkInstance,\n                state.input.pushBatchSize,\n                lastCheckpoint\n            );\n            if (upResult.documents.length === 0) {\n                break;\n            }\n\n            lastCheckpoint = stackCheckpoints([lastCheckpoint, upResult.checkpoint]);\n\n            const promise = persistToMaster(\n                upResult.documents,\n                ensureNotFalsy(lastCheckpoint)\n            );\n            promises.add(promise);\n            promise.catch().then(() => promises.delete(promise));\n        }\n\n        /**\n         * If we had conflicts during the initial sync,\n         * it means that we likely have new writes to the fork\n         * and so we have to run the initial sync again to upstream these new writes.\n         */\n        const resolvedPromises = await Promise.all(promises);\n        const hadConflicts = resolvedPromises.find(r => !!r);\n        if (hadConflicts) {\n            await upstreamInitialSync();\n        } else if (\n            !state.firstSyncDone.up.getValue() &&\n            !state.events.canceled.getValue()\n        ) {\n            state.firstSyncDone.up.next(true);\n        }\n    }\n\n\n    /**\n     * Takes all open tasks an processes them at once.\n     */\n    function processTasks() {\n        if (\n            state.events.canceled.getValue() ||\n            openTasks.length === 0\n        ) {\n            state.events.active.up.next(false);\n            return;\n        }\n        state.stats.up.processTasks = state.stats.up.processTasks + 1;\n        state.events.active.up.next(true);\n        state.streamQueue.up = state.streamQueue.up.then(async () => {\n            /**\n             * Merge/filter all open tasks\n             */\n            const docs: RxDocumentData<RxDocType>[] = [];\n            let checkpoint: CheckpointType | undefined;\n            while (openTasks.length > 0) {\n                const taskWithTime = ensureNotFalsy(openTasks.shift());\n                console.log('[RXDB_UPSTREAM] processTasks tasks: ', taskWithTime);\n                /**\n                 * If the task came in before the last time the initial sync fetching\n                 * has run, we can ignore the task because the initial sync already processed\n                 * these documents.\n                 */\n                if (taskWithTime.time < initialSyncStartTime) {\n                    console.log('[RXDB_UPSTREAM] processTasks skip task: ', taskWithTime);\n                    continue;\n                }\n\n                if (taskWithTime.task === 'RESYNC') {\n                    console.log('[RXDB_UPSTREAM] processTasks RESYNC task: ', taskWithTime);\n                    state.events.active.up.next(false);\n                    await upstreamInitialSync();\n                    return;\n                }\n\n                /**\n                 * If the task came from the downstream, we can ignore these documents\n                 * because we know they are replicated already.\n                 * But even if they can be ignored, we later have to call persistToMaster()\n                 * to have the correct checkpoint set.\n                 */\n                if (taskWithTime.task.context !== await state.downstreamBulkWriteFlag) {\n                    console.log('[RXDB_UPSTREAM] processTasks downstraem task: ', taskWithTime);\n                    appendToArray(\n                        docs,\n                        taskWithTime.task.events.map(r => {\n                            return r.documentData as any;\n                        })\n                    );\n                }\n                checkpoint = stackCheckpoints([checkpoint, taskWithTime.task.checkpoint]);\n                console.log('[RXDB_UPSTREAM] processTasks downstraem: ', checkpoint);\n            }\n\n            await persistToMaster(\n                docs,\n                checkpoint as any\n            );\n\n            // might have got more tasks while running persistToMaster()\n            if (openTasks.length === 0) {\n                state.events.active.up.next(false);\n            } else {\n                return processTasks();\n            }\n        });\n    }\n\n    /**\n     * Returns true if had conflicts,\n     * false if not.\n     */\n    function persistToMaster(\n        docs: RxDocumentData<RxDocType>[],\n        checkpoint: CheckpointType\n    ): Promise<boolean> {\n        state.stats.up.persistToMaster = state.stats.up.persistToMaster + 1;\n\n        /**\n         * Add the new docs to the non-persistent list\n         */\n        docs.forEach(docData => {\n            const docId: string = (docData as any)[state.primaryPath];\n            nonPersistedFromMaster.docs[docId] = docData;\n        });\n        nonPersistedFromMaster.checkpoint = checkpoint;\n        console.log('[RXDB_UPSTREAM] persistToMaster nonPersistedFromMaster: ', nonPersistedFromMaster);\n\n        persistenceQueue = persistenceQueue.then(async () => {\n            if (state.events.canceled.getValue()) {\n                return false;\n            }\n\n            console.log('[RXDB_UPSTREAM] persistToMaster persistenceQueue start: ', nonPersistedFromMaster);\n\n            const upDocsById: ById<RxDocumentData<RxDocType>> = nonPersistedFromMaster.docs;\n            nonPersistedFromMaster.docs = {};\n            const useCheckpoint = nonPersistedFromMaster.checkpoint;\n            const docIds = Object.keys(upDocsById);\n\n            /**\n             * Even if we do not have anything to push,\n             * we still have to store the up-checkpoint.\n             * This ensures that when many documents have been pulled\n             * from the remote (that do not have to be pushed again),\n             * we continue at the correct position and do not have to load\n             * these documents from the storage again when the replication is restarted.\n             */\n            function rememberCheckpointBeforeReturn() {\n                return setCheckpoint(\n                    state,\n                    'up',\n                    useCheckpoint\n                );\n            };\n\n\n            if (docIds.length === 0) {\n                console.log('[RXDB_UPSTREAM] persistToMaster persistenceQueue: rememberCheckpointBeforeReturn docsId.length is 0');\n                rememberCheckpointBeforeReturn();\n                return false;\n            }\n\n            const assumedMasterState = await getAssumedMasterState(\n                state,\n                docIds\n            );\n\n            console.log('[RXDB_UPSTREAM] persistToMaster persistenceQueue assumedMasterState: ', assumedMasterState);\n\n            const writeRowsToMaster: ById<RxReplicationWriteToMasterRow<RxDocType>> = {};\n            const writeRowsToMasterIds: string[] = [];\n            const writeRowsToMeta: BulkWriteRowById<RxStorageReplicationMeta<RxDocType, any>> = {};\n            const forkStateById: ById<RxDocumentData<RxDocType>> = {};\n\n            await Promise.all(\n                docIds.map(async (docId) => {\n                    const fullDocData: RxDocumentData<RxDocType> = upDocsById[docId];\n                    forkStateById[docId] = fullDocData;\n                    const docData: WithDeleted<RxDocType> = writeDocToDocState(fullDocData, state.hasAttachments, !!state.input.keepMeta);\n                    const assumedMasterDoc = assumedMasterState[docId];\n\n                    console.log('[RXDB_UPSTREAM] persistToMaster persistenceQueue processing docData: ', docData);\n                    console.log('[RXDB_UPSTREAM] persistToMaster persistenceQueue processing assumedMasterDoc: ', assumedMasterDoc);\n                    console.log('[RXDB_UPSTREAM] persistToMaster persistenceQueue processing isResolvedConflict correct: ', (\n                        assumedMasterDoc &&\n                        // if the isResolvedConflict is correct, we do not have to compare the documents.\n                        assumedMasterDoc.metaDocument.isResolvedConflict !== fullDocData._rev\n                        &&\n                        (\n                            state.input.conflictHandler.isEqual(\n                                assumedMasterDoc.docData,\n                                docData,\n                                'upstream-check-if-equal'\n                            )\n                        )\n                    ) || (\n                        assumedMasterDoc &&\n                        (assumedMasterDoc.docData as any)._rev &&\n                        getHeightOfRevision(fullDocData._rev) === fullDocData._meta[state.input.identifier]\n                    ));\n\n                    /**\n                     * If the master state is equal to the\n                     * fork state, we can assume that the document state is already\n                     * replicated.\n                     */\n                    if (\n                        (\n                            assumedMasterDoc &&\n                            // if the isResolvedConflict is correct, we do not have to compare the documents.\n                            assumedMasterDoc.metaDocument.isResolvedConflict !== fullDocData._rev\n                            &&\n                            (\n                                state.input.conflictHandler.isEqual(\n                                    assumedMasterDoc.docData,\n                                    docData,\n                                    'upstream-check-if-equal'\n                                )\n                            )\n                        )\n                        ||\n                        /**\n                         * If the master works with _rev fields,\n                         * we use that to check if our current doc state\n                         * is different from the assumedMasterDoc.\n                         */\n                        (\n                            assumedMasterDoc &&\n                            (assumedMasterDoc.docData as any)._rev &&\n                            getHeightOfRevision(fullDocData._rev) === fullDocData._meta[state.input.identifier]\n                        )\n                    ) {\n                        return;\n                    }\n\n                    writeRowsToMasterIds.push(docId);\n\n                    writeRowsToMaster[docId] = {\n                        assumedMasterState: assumedMasterDoc ? assumedMasterDoc.docData : undefined,\n                        newDocumentState: docData\n                    };\n                    writeRowsToMeta[docId] = await getMetaWriteRow(\n                        state,\n                        docData,\n                        assumedMasterDoc ? assumedMasterDoc.metaDocument : undefined\n                    );\n                })\n            );\n\n            if (writeRowsToMasterIds.length === 0) {\n                console.log('[RXDB_UPSTREAM] persistToMaster persistenceQueue processing: rememberCheckpointBeforeReturn writeRowsToMasterIds.length is 0');\n                rememberCheckpointBeforeReturn();\n                return false;\n            }\n\n\n            const writeRowsArray = Object.values(writeRowsToMaster);\n            const conflictIds: Set<string> = new Set();\n            const conflictsById: ById<WithDeleted<RxDocType>> = {};\n\n            /**\n             * To always respect the push.batchSize,\n             * we have to split the write rows into batches\n             * to ensure that replicationHandler.masterWrite() is never\n             * called with more documents than what the batchSize limits.\n             */\n            const writeBatches = batchArray(writeRowsArray, state.input.pushBatchSize);\n\n            console.log('[RXDB_UPSTREAM] persistToMaster persistenceQueue processing writeBatches: ', writeBatches);\n\n            await Promise.all(\n                writeBatches.map(async (writeBatch) => {\n                    // enhance docs with attachments\n                    if (state.hasAttachments) {\n                        await Promise.all(\n                            writeBatch.map(async (row) => {\n                                row.newDocumentState = await fillWriteDataForAttachmentsChange(\n                                    state.primaryPath,\n                                    state.input.forkInstance,\n                                    clone(row.newDocumentState),\n                                    row.assumedMasterState\n                                );\n                            })\n                        );\n                    }\n                    const masterWriteResult = await replicationHandler.masterWrite(writeBatch);\n                    masterWriteResult.forEach(conflictDoc => {\n                        const id = (conflictDoc as any)[state.primaryPath];\n                        conflictIds.add(id);\n                        conflictsById[id] = conflictDoc;\n                    });\n                })\n            );\n\n            console.log('[RXDB_UPSTREAM] persistToMaster persistenceQueue processing conflictsById: ', conflictsById);\n\n            const useWriteRowsToMeta: BulkWriteRow<RxStorageReplicationMeta<RxDocType, any>>[] = [];\n\n            writeRowsToMasterIds.forEach(docId => {\n                if (!conflictIds.has(docId)) {\n                    state.events.processed.up.next(writeRowsToMaster[docId]);\n                    useWriteRowsToMeta.push(writeRowsToMeta[docId]);\n                }\n            });\n\n            if (state.events.canceled.getValue()) {\n                return false;\n            }\n\n            console.log('[RXDB_UPSTREAM] persistToMaster persistenceQueue processing useWriteRowsToMeta: ', useWriteRowsToMeta);\n\n            if (useWriteRowsToMeta.length > 0) {\n                await state.input.metaInstance.bulkWrite(\n                    stripAttachmentsDataFromMetaWriteRows(state, useWriteRowsToMeta),\n                    'replication-up-write-meta'\n                );\n                // TODO what happens when we have conflicts here?\n            }\n\n            /**\n             * Resolve conflicts by writing a new document\n             * state to the fork instance and the 'real' master state\n             * to the meta instance.\n             * Non-409 errors will be detected by resolveConflictError()\n             */\n            let hadConflictWrites = false;\n            if (conflictIds.size > 0) {\n                console.log('[RXDB_UPSTREAM] persistToMaster persistenceQueue processing conflicts: ', conflictsById);\n                state.stats.up.persistToMasterHadConflicts = state.stats.up.persistToMasterHadConflicts + 1;\n                const conflictWriteFork: BulkWriteRow<RxDocType>[] = [];\n                const conflictWriteMeta: BulkWriteRowById<RxStorageReplicationMeta<RxDocType, any>> = {};\n                await Promise.all(\n                    Object\n                        .entries(conflictsById)\n                        .map(([docId, realMasterState]) => {\n                            const writeToMasterRow = writeRowsToMaster[docId];\n                            const input = {\n                                newDocumentState: writeToMasterRow.newDocumentState,\n                                assumedMasterState: writeToMasterRow.assumedMasterState,\n                                realMasterState\n                            };\n                            console.log('[RXDB_UPSTREAM] persistToMaster persistenceQueue processing conflict writeToMasterRow: ', writeToMasterRow);\n                            console.log('[RXDB_UPSTREAM] persistToMaster persistenceQueue processing conflict input: ', input);\n                            return resolveConflictError(\n                                state,\n                                input,\n                                forkStateById[docId]\n                            ).then(async (resolved) => {\n                                console.log('[RXDB_UPSTREAM] persistToMaster persistenceQueue processing resolved: ', resolved);\n                                if (resolved) {\n                                    state.events.resolvedConflicts.next({\n                                        input,\n                                        output: resolved\n                                    });\n                                    conflictWriteFork.push({\n                                        previous: forkStateById[docId],\n                                        document: resolved\n                                    });\n                                    const assumedMasterDoc = assumedMasterState[docId];\n                                    conflictWriteMeta[docId] = await getMetaWriteRow(\n                                        state,\n                                        ensureNotFalsy(realMasterState),\n                                        assumedMasterDoc ? assumedMasterDoc.metaDocument : undefined,\n                                        resolved._rev\n                                    );\n                                }\n                            });\n                        })\n                );\n\n                console.log('[RXDB_UPSTREAM] persistToMaster persistenceQueue processing conflictWriteFork: ', conflictWriteFork);\n\n                if (conflictWriteFork.length > 0) {\n                    hadConflictWrites = true;\n\n                    state.stats.up.persistToMasterConflictWrites = state.stats.up.persistToMasterConflictWrites + 1;\n                    const forkWriteResult = await state.input.forkInstance.bulkWrite(\n                        conflictWriteFork,\n                        'replication-up-write-conflict'\n                    );\n\n                    let mustThrow: RxError | undefined;\n                    forkWriteResult.error.forEach(error => {\n                        /**\n                         * Conflict-Errors in the forkWriteResult must not be handled\n                         * because they have been caused by a write to the forkInstance\n                         * in between which will anyway trigger a new upstream cycle\n                         * that will then resolved the conflict again.\n                         */\n                        if (error.status === 409) {\n                            return;\n                        }\n                        // other non-conflict errors must be handled\n                        const throwMe = newRxError('RC_PUSH', {\n                            writeError: error\n                        });\n                        state.events.error.next(throwMe);\n                        mustThrow = throwMe;\n                    });\n                    if (mustThrow) {\n                        throw mustThrow;\n                    }\n\n                    const useMetaWrites: BulkWriteRow<RxStorageReplicationMeta<RxDocType, any>>[] = [];\n                    const success = getWrittenDocumentsFromBulkWriteResponse(\n                        state.primaryPath,\n                        conflictWriteFork,\n                        forkWriteResult\n                    );\n                    success\n                        .forEach(docData => {\n                            const docId = (docData as any)[state.primaryPath];\n                            useMetaWrites.push(\n                                conflictWriteMeta[docId]\n                            );\n                        });\n                    if (useMetaWrites.length > 0) {\n                        await state.input.metaInstance.bulkWrite(\n                            stripAttachmentsDataFromMetaWriteRows(state, useMetaWrites),\n                            'replication-up-write-conflict-meta'\n                        );\n                    }\n                    // TODO what to do with conflicts while writing to the metaInstance?\n                }\n            }\n\n            /**\n             * For better performance we do not await checkpoint writes,\n             * but to ensure order on parallel checkpoint writes,\n             * we have to use a queue.\n             */\n            console.log('[RXDB_UPSTREAM] persistToMaster persistenceQueue processing last rememberCheckpointBeforeReturn');\n            rememberCheckpointBeforeReturn();\n\n            return hadConflictWrites;\n        }).catch(unhandledError => {\n            state.events.error.next(unhandledError);\n            return false;\n        });\n\n        return persistenceQueue;\n    }\n}\n"],"mappings":"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","ignoreList":[]}